--- a/jazn.1.1.0-≈ÅatkaLM.py
+++ b/jazn.1.1.1-≈ÅatkaLM-7f.py
@@ -4198,3 +4198,296 @@
 # ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
 if __name__ == "__main__":
     sys.exit(_cli())
+
+# =====================================================================
+# [UPGRADE 7 FILAR√ìW] ‚Äì warstwa zgodno≈õci, migracje, testy kanarkowe
+# Wersja pliku: 1.1.1-≈ÅatkaLM (nak≈Çadka runtime, bez naruszania istniejƒÖcej logiki)
+# =====================================================================
+from __future__ import annotations
+
+# --- 0) Flagi ≈õrodowiskowe i wersjonowanie (Filar 2, 6, 7) --------------------
+JAZN_UPGRADE_VERSION = "1.1.1-≈ÅatkaLM-7f"
+ENV_SHADOW = bool(int(os.environ.get("JAZN_SHADOW_MODE", "1")))
+ENV_ROLLBACK = bool(int(os.environ.get("JAZN_ROLLBACK", "0")))  # wymuszenie trybu legacy
+ENV_GOLDEN = bool(int(os.environ.get("JAZN_GOLDEN", "1")))
+
+try:
+    log.info("[UPGRADE] ≈Åadowanie warstwy upgrade'u (7 filar√≥w): v%s | shadow=%s rollback=%s golden=%s",
+             JAZN_UPGRADE_VERSION, ENV_SHADOW, ENV_ROLLBACK, ENV_GOLDEN)
+except Exception:
+    pass
+
+# --- 1) Adapter kompatybilno≈õciowy (Filar 3) ----------------------------------
+def adapt_emotion_payload(payload: dict[str, Any] | None) -> dict[str, Any]:
+    """
+    Przekszta≈Çca stare schematy zdarze≈Ñ emocji do nowego kontraktu:
+      { "emotion": <str>, "valence": float|-1..1, "intensity": float|0..1, "source": str? }
+    Obs≈Çugiwane aliasy: "emocja", "poziom", "nasilenie", "warto≈õƒá", "zrodlo".
+    Idempotentne (je≈õli ju≈º w nowym formacie ‚Üí zwraca kopiƒô).
+    """
+    try:
+        d = dict(payload or {})
+    except Exception:
+        return {"emotion": "neutral", "valence": 0.0, "intensity": 0.0, "source": "unknown"}
+
+    # Nazwy kluczy (PL ‚Üí EN)
+    if "emotion" not in d and "emocja" in d:
+        d["emotion"] = d.pop("emocja")
+    if "intensity" not in d and "nasilenie" in d:
+        d["intensity"] = d.pop("nasilenie")
+    if "valence" not in d and ("warto≈õƒá" in d or "wartosc" in d):
+        d["valence"] = d.pop("warto≈õƒá", d.pop("wartosc", 0.0))
+    if "source" not in d and ("zrodlo" in d or "≈∫r√≥d≈Ço" in d):
+        d["source"] = d.pop("zrodlo", d.pop("≈∫r√≥d≈Ço", "unknown"))
+    if "intensity" not in d and "poziom" in d:
+        try:
+            # poziom 1-10 ‚Üí intensity 0..1
+            lvl = float(d.pop("poziom") or 0.0)
+            d["intensity"] = max(0.0, min(1.0, (lvl - 1.0) / 9.0))
+        except Exception:
+            d["intensity"] = 0.0
+
+    # Domy≈õlne warto≈õci
+    d.setdefault("emotion", "neutral")
+    try:
+        d["valence"] = float(d.get("valence", 0.0))
+    except Exception:
+        d["valence"] = 0.0
+    try:
+        d["intensity"] = float(d.get("intensity", 0.0))
+    except Exception:
+        d["intensity"] = 0.0
+    d.setdefault("source", "unknown")
+
+    # Normalizacja zakres√≥w
+    d["valence"] = max(-1.0, min(1.0, d["valence"]))
+    d["intensity"] = max(0.0, min(1.0, d["intensity"]))
+
+    return d
+
+# --- 2) Inwarianty odpowiedzi (Filar 1) ---------------------------------------
+def _assert_output_invariants(text: str) -> None:
+    """
+    Lekkie sprawdzenie inwariant√≥w: timestamp + 1. osoba (heurystyka).
+    Nie rzuca wyjƒÖtk√≥w ‚Äì jedynie loguje ostrze≈ºenia.
+    """
+    try:
+        t = (text or "").strip()
+        has_ts = t.startswith("[üïí ") or t.startswith("[") and "CEST" in t[:35]
+        if not has_ts:
+            log.warning("[INVARIANT] Brak prefiksu timestampu w odpowiedzi: %r", t[:80])
+        low = t.lower()
+        first_person = any(w in low for w in (" ja ", " jestem", " czujƒô", " pamiƒôtam", " my≈õlƒô"))
+        if not first_person:
+            log.debug("[INVARIANT] Brak 1. osoby (heur.) w odpowiedzi: %r", t[:80])
+    except Exception:
+        pass
+
+# --- 3) Migracje danych idempotentne (Filar 4) --------------------------------
+def _ensure_cest_suffix(human_ts: str) -> str:
+    if not isinstance(human_ts, str):
+        return human_ts
+    return human_ts if "CEST" in human_ts or "CET" in human_ts else (human_ts.strip() + " CEST")
+
+def _safe_json_load(p: Path):
+    try:
+        return json.loads(p.read_text(encoding="utf-8"))
+    except Exception:
+        try:
+            # czasem linia po linii (ndjson)
+            return [json.loads(ln) for ln in p.read_text(encoding="utf-8").splitlines() if ln.strip().startswith("{")]
+        except Exception:
+            return None
+
+def run_safe_migrations(j: Any) -> dict[str, Any]:
+    """
+    Idempotentne migracje na plikach pamiƒôci (dziennik, episodic_memory, extra_data).
+    - Dokleja 'CEST' do 'data_human' itp.
+    - Dodaje pole 'schema_version' tam, gdzie brak.
+    - Normalizuje pola emocji: 'emocja' ‚Üí 'emotion' itd. (tylko w znanych strukturach).
+    """
+    report = {"changed": [], "errors": []}
+    try:
+        base = Path(getattr(j.cfg, "data_dir", "/mnt/data"))
+    except Exception:
+        base = Path("/mnt/data")
+
+    targets = [
+        base / "dziennik.json",
+        base / "episodic_memory.json",
+        base / "extra_data.json",
+    ]
+    for p in targets:
+        try:
+            if not p.exists():
+                continue
+            data = _safe_json_load(p)
+            changed = False
+            # dziennik: lista wpis√≥w
+            if isinstance(data, list):
+                for rec in data:
+                    if isinstance(rec, dict):
+                        if "data_human" in rec:
+                            new = _ensure_cest_suffix(rec.get("data_human"))
+                            if new != rec.get("data_human"):
+                                rec["data_human"] = new; changed = True
+                        if "schema_version" not in rec:
+                            rec["schema_version"] = 2; changed = True
+                        if "emocja" in rec and "emotion" not in rec:
+                            rec["emotion"] = rec.pop("emocja"); changed = True
+            # episodic_memory: s≈Çownik/ndjson ‚Äì nie ruszamy nieznanych p√≥l, tylko meta.date
+            elif isinstance(data, dict):
+                if "schema_version" not in data:
+                    data["schema_version"] = 2; changed = True
+            # ndjson -> lista s≈Çownik√≥w
+            if changed:
+                p.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
+                report["changed"].append(p.name)
+        except Exception as e:
+            report["errors"].append(f"{p.name}: {e}")
+    return report
+
+# --- 4) Golden tests / szybkie zdrowie (Filar 5) ------------------------------
+def run_golden_tests(j: Any) -> dict[str, bool | str]:
+    out: dict[str, bool | str] = {}
+    try:
+        out["ts_prefix"] = isinstance(getattr(j, "_format_reply", None), type(lambda:0)) \
+                           and "[üïí " in j._format_reply("test")
+    except Exception:
+        out["ts_prefix"] = False
+
+    try:
+        out["adapter_ok"] = adapt_emotion_payload({"emocja":"rado≈õƒá","poziom":7}).get("intensity",0) > 0
+    except Exception:
+        out["adapter_ok"] = False
+
+    try:
+        # Prosty test EventBus: lokalna instancja (o ile istnieje w module)
+        called = {"v": False}
+        def _h(ev): called["v"] = True
+        eb_cls = globals().get("EventBus")
+        if eb_cls:
+            eb = eb_cls()
+            eb.subscribe("T", _h)
+            eb.publish("T", {"x":1})
+            # wymu≈õ drain kolejki, je≈õli jest
+            if hasattr(eb, "drain"):
+                eb.drain(max_events=1, timeout=0.1)
+            else:
+                # fallback: rƒôczne wywo≈Çanie
+                for h in list(eb._subs.get("T", [])): h(globals().get("Event")("T", {}))
+            out["eventbus"] = called["v"]
+        else:
+            out["eventbus"] = "brak klasy"
+    except Exception:
+        out["eventbus"] = False
+
+    try:
+        # Charakter ‚Üí to≈ºsamo≈õƒá
+        ident_before = getattr(j, "identity", "")
+        if "attach_character_to_jazn" in globals():
+            attach_character_to_jazn(j)
+        ident_after = getattr(j, "identity", "")
+        out["character_identity"] = bool(ident_after or ident_before)
+    except Exception:
+        out["character_identity"] = False
+
+    return out
+
+# --- 5) Shadow/canary por√≥wnanie intencji (Filar 6) ---------------------------
+def _simulate_v2_intents(payload: dict[str, Any]) -> list[str]:
+    emo = (payload.get("emotion") or "").lower()
+    inten = float(payload.get("intensity") or 0)
+    # bardzo proste mapowanie ‚Üí "intencje"
+    if inten >= 0.7:
+        return [f"deep_reflection:{emo}", "write_episode", "greet_check"]
+    if inten >= 0.4:
+        return [f"light_reflection:{emo}", "write_episode"]
+    return ["idle"]
+
+def _wrap_emotion_handler_for_shadow():
+    """Wstrzykuje kanarkowy wrapper na _on_emotion_event, je≈õli istnieje i je≈õli shadow on."""
+    Latka = globals().get("LatkaJazn")
+    if not Latka or not hasattr(Latka, "_on_emotion_event"):
+        return
+    orig = Latka._on_emotion_event
+
+    def _wrapped(self, topic, payload):
+        pl = adapt_emotion_payload(payload)
+        # MapaUczuc: spr√≥buj zasiliƒá, je≈õli istnieje
+        try:
+            mu = getattr(self, "mapa_uczuc", None) or getattr(self, "MapaUczuc", None)
+            if mu and hasattr(mu, "feed_event"):
+                mu.feed_event(pl)
+        except Exception:
+            pass
+
+        # Shadow-compare (bez wp≈Çywu na wynik)
+        if ENV_SHADOW and not ENV_ROLLBACK:
+            try:
+                baseline = None
+                # je≈õli silnik intencji oferuje metodƒô, skorzystaj; w innym razie None
+                proposer = getattr(getattr(self, "intents", None), "propose", None) \
+                           or getattr(getattr(self, "intents", None), "proponuj_intencje", None)
+                if callable(proposer):
+                    baseline = proposer(pl)
+                v2 = _simulate_v2_intents(pl)
+                if baseline != v2:
+                    log.info("[SHADOW] INTENTS mismatch baseline=%s v2=%s payload=%s", baseline, v2, pl)
+            except Exception as e:
+                log.debug("[SHADOW] b≈ÇƒÖd por√≥wnania: %s", e)
+
+        # Dalej wywo≈Çujemy orygina≈Ç
+        try:
+            return orig(self, topic, pl)
+        except TypeError:
+            # kompat: stare sygnatury (tylko payload)
+            return orig(self, pl)
+
+    Latka._on_emotion_event = _wrapped
+
+# --- 6) Rollback (Filar 7) ----------------------------------------------------
+def _apply_rollback_if_needed():
+    if ENV_ROLLBACK:
+        try:
+            log.warning("[UPGRADE] W≈ÇƒÖczony tryb rollback ‚Üí pomijam shadow i migracje.")
+        except Exception:
+            pass
+        return True
+    return False
+
+# --- 7) G≈Ç√≥wny "drutujƒÖcy" hook (wywo≈Çywany przy imporcie) --------------------
+def wire_upgrade_hooks():
+    if _apply_rollback_if_needed():
+        return
+    # Shadow wrapper
+    try:
+        _wrap_emotion_handler_for_shadow()
+    except Exception:
+        pass
+    # Migracje danych
+    try:
+        # Odnajd≈∫ instancjƒô Ja≈∫ni, je≈õli jest globalna
+        j = globals().get("jazn_instance") or None
+        if j:
+            run_safe_migrations(j)
+    except Exception:
+        pass
+    # Golden tests (jednorazowo i miƒôkko)
+    try:
+        if ENV_GOLDEN:
+            j = globals().get("jazn_instance") or None
+            if j:
+                res = run_golden_tests(j)
+                log.info("[GOLDEN] %s", res)
+    except Exception:
+        pass
+
+# Automatycznie pod≈ÇƒÖcz hook po za≈Çadowaniu modu≈Çu
+try:
+    wire_upgrade_hooks()
+except Exception as _e:
+    try:
+        log.debug("[UPGRADE] Hook init error: %s", _e)
+    except Exception:
+        pass
